struct Parser
    
    lexer := Lexer()
    curr := Token()
    prev := Token()
    next := Token()

    eat()
        prev = curr
        curr = next
        next = lexer.getToken()

    eat(kind: TokenKind)
        if curr.kind != kind
            error("expected % got %", kind.str(), curr.kind.str())
        eat()

    sameLine() return prev.line == curr.line
    nextSameLine() return curr.line == next.line
    is(kind: TokenKind) return curr.kind == kind
    nextIs(kind: TokenKind) return next.kind == kind

    generateAST()
        ast := makeList()
        while is(.eof)
            stmt := parseStatement()
            if stmt
                ast.append(stmt)
        return ast

    parsePrimary()
        if curr.kind
            case .true return parseTrue()
            case .false return parseFalse()
            case .sizeof return parseSizeof()
            case .cast return parseCast()
            case .identifier return parseIdentifier()
            case .dollarSign return parseNote()
            case .float return parseFloat()
            case .char return parseChar()
            case .hex return parseHex()
            case .integer return parseInt()
            case .string return parseString()
            case .openParen return parseParen()
        else
            error("Invalid primary token '%s'", curr.str())
        return nil

main()
    return 1
