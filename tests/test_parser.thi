struct Parser
    
    lexer := Lexer()
    curr := Token()
    prev := Token()
    next := Token()

    eat()
        prev = curr
        curr = next
        next = lexer.getToken()

    eat(kind: TokenKind)
        if curr.kind != kind error("expected % got %", kind.str(), curr.kind.str())
        eat()

    sameLine() return prev.line == curr.line
    nextSameLine() return curr.line == next.line
    isCurr(kind: TokenKind) return curr.kind == kind
    isNext(kind: TokenKind) return next.kind == kind

    generateAST()
        ast := makeList()
        while !isCurr(.eof)
            stmt := parseStatement()
            if stmt ast.append(stmt)
        return ast

    Parser.parsePrimary()
        if curr.kind
            is .true return parseTrue()
            is .false return parseFalse()
            is .sizeof return parseSizeof()
            is .cast return parseCast()
            is .identifier return parseIdentifier()
            is .dollarSign return parseNote()
            is .float return parseFloat()
            is .char return parseChar()
            is .hex return parseHex()
            is .integer return parseInt()
            is .string return parseString()
            is .openParen return parseParen()
        else error("Invalid primary token '%s'", curr.str())
        return nil

main()
    return 1
