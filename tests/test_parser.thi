# Dependencies:
#   function name mangling
#   struct methods

def main(argc int, argc char**)
    sourceFile = argv[2]
    asm = compile(sourceFile)
    name = getFileName(sourceFile)
    writeToFile(name, asm)
    return 1

def compile(source)
    tokens = makeTokens(source)
    ast    = makeAST(tokens)
    code   = makeX64(ast)
    return code

def Array(T) class

    data T* = 0
    len = 0
    cap = 0

    def += (item T)
        reserveSpace(len+1)
        data[len++] = item

    def += (items Array(T))
        reserveSpace(items.count)
        for el in items
            data[len++] = el
    
    def reserveSpace(count)
        if len + count > cap
            cap += count
            data = realloc(data, cap)


def __TypeKind enum
    Unresolved
    Void
    Int
    Float
    String
    Pointer
    Array
    Enum
    Struct
    Function
    Var_args

def __Type struct
    name char*
    flags u32
    kind __TypeKind

def TokenKind enum
    Identifier
    Int
    Float
    String
    Newline
    EOF
    def count() => __TypeID(*this).members.count
    def str()
        for member in __TypeID(*this).members
            member.value == *this
            return member.name

def Token struct
    kind TokenKind = .__Unknown
    value u8* = 0
    line s64 = 1
    col s64 = 0

def Lexer class
    cursor u8* = 0
    def eatUntil(c)
        while *cursor != c ++cursor
    def getToken()
        c = cursor
        if *c
            is '_' => while isAlpha(*c) eat(); .Identifier
            is [0-9] => eatUntil(' '); .Number

def Parser class

    lexer = Lexer()

    curr = Token()
    prev = Token()
    next = Token()

    def eat()
        prev = curr
        curr = next
        next = lexer.getToken()

    def eat(kind)
        if curr.kind != kind error("expected % got %", kind.str(), curr.kind.str())
        eat()

    def sameLine() => prev.line == curr.line
    def nextSameLine() => curr.line == next.line
    def isCurr(kind) => curr.kind == kind
    def isNext(kind) => next.kind == kind

    def generateAST()
        eat() # prime the first token
        ast = []
        while !isCurr(.EOF)
            stmt = parseStatement()
            if stmt ast += stmt
        return ast

    def parsePrimary()
        if curr.kind
            is .True => parseTrue()
            is .False => parseFalse()
            is .Sizeof => parseSizeof()
            is .Cast => parseCast()
            is .Identifier => parseIdentifier()
            is .DollarSign => parseNote()
            is .Float => parseFloat()
            is .Char => parseChar()
            is .Hex => parseHex()
            is .Integer => parseInt()
            is .String => parseString()
            is .OpenParen => parseParen()
        else error("Invalid primary token '%s'", curr.str())
