struct Parser
    
    lexer := Lexer()
    curr := Token()
    prev := Token()
    next := Token()

    def eat()
        prev = curr
        curr = next
        next = lexer.getToken()

    def eat(kind TokenKind)
        if curr.kind != kind
            error("expected % got %", kind.str(), curr.kind.str())
        eat()

    def sameLine() return prev.line == curr.line
    def nextSameLine() return curr.line == next.line
    def is(kind TokenKind) return curr.kind == kind
    def nextIs(kind TokenKind) return next.kind == kind

    def generateAST()
        ast := makeList()
        while is(.eof)
            stmt := parseStatement()
            if stmt
                ast.append(stmt)
        return ast

    def parsePrimary()
        if curr.kind
            case .true return parseTrue()
            case .false return parseFalse()
            case .sizeof return parseSizeof()
            case .cast return parseCast()
            case .identifier return parseIdentifier()
            case .dollarSign return parseNote()
            case .float return parseFloat()
            case .char return parseChar()
            case .hex return parseHex()
            case .integer return parseInt()
            case .string return parseString()
            case .openParen return parseParen()
        else
            error("Invalid primary token '%s'", curr.str())
        return nil

def main()
    return 1
